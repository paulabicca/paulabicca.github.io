<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Javascript on Paula Bicca</title><link>https://paulabicca.github.io/en/categories/javascript/</link><description>Recent content in Javascript on Paula Bicca</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 22 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://paulabicca.github.io/en/categories/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>Is Vanilla JavaScript Dead?</title><link>https://paulabicca.github.io/en/p/is-vanilla-javascript-dead/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate><guid>https://paulabicca.github.io/en/p/is-vanilla-javascript-dead/</guid><description>&lt;p>If you’re a front-end developer, you’ve likely noticed that “front-end developer” job postings are becoming increasingly rare. Nowadays, the market seeks developers proficient in &lt;strong>React&lt;/strong>, &lt;strong>Angular&lt;/strong>, or &lt;strong>Vue.js&lt;/strong>, and experience with &lt;strong>JavaScript&lt;/strong> is often considered a “plus” or not even required. This raises the question: is Vanilla JavaScript really &amp;ldquo;dead&amp;rdquo;?&lt;/p>
&lt;h2 id="what-is-vanilla-javascript">What is Vanilla JavaScript?
&lt;/h2>&lt;p>&amp;ldquo;Vanilla JavaScript&amp;rdquo; refers to using JavaScript in its pure form, without relying on additional frameworks or libraries. It’s the basic JavaScript language that can be executed directly in the browser, without tools like &lt;strong>React&lt;/strong>, &lt;strong>Angular&lt;/strong>, or &lt;strong>Vue.js&lt;/strong>.&lt;/p>
&lt;p>When we talk about Vanilla JavaScript, we mean leveraging the language&amp;rsquo;s native features, utilizing browser APIs, and relying on fundamental JavaScript capabilities.&lt;/p>
&lt;h2 id="why-have-frameworks-dominated-front-end-development">Why Have Frameworks Dominated Front-End Development?
&lt;/h2>&lt;p>It’s easy to see why frameworks like &lt;strong>React&lt;/strong>, &lt;strong>Angular&lt;/strong>, and &lt;strong>Vue.js&lt;/strong> have become so dominant. These frameworks offer several advantages, especially for large-scale projects, such as:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Componentization:&lt;/strong> Structures that make code more modular and reusable.&lt;/li>
&lt;li>&lt;strong>State Management:&lt;/strong> Tools to handle complex states in large applications.&lt;/li>
&lt;li>&lt;strong>Improved Performance:&lt;/strong> Algorithms that update the DOM more efficiently.&lt;/li>
&lt;li>&lt;strong>Ease of Development:&lt;/strong> Ready-to-use features like routing and form validation, saving development time.&lt;/li>
&lt;/ul>
&lt;p>These functionalities have made developers’ lives significantly easier and accelerated the development of complex applications. It’s no surprise that frameworks like React have become the preferred choice for many companies and developers.&lt;/p>
&lt;h2 id="so-is-vanilla-javascript-really-dead">So, Is Vanilla JavaScript Really &amp;ldquo;Dead&amp;rdquo;?
&lt;/h2>&lt;p>The answer is &lt;strong>no&lt;/strong>. While the job market focuses on frameworks, &lt;strong>Vanilla JavaScript&lt;/strong> remains highly relevant. According to &lt;a class="link" href="https://innovationgraph.github.com/global-metrics/programming-languages" target="_blank" rel="noopener"
>GitHub metrics for 2024&lt;/a>, JavaScript is still one of the most widely used programming languages in the world. Even with the rise of &lt;a class="link" href="https://github.blog/news-insights/octoverse/octoverse-2024/" target="_blank" rel="noopener"
>TypeScript&lt;/a>, which adds static typing to JavaScript, knowledge of Vanilla JavaScript remains essential.&lt;/p>
&lt;p>JavaScript is the foundation of modern frameworks. Even if you’re working with React or Vue, it’s crucial to understand how the &lt;strong>DOM&lt;/strong> works, how to manipulate elements, and grasp fundamental JavaScript concepts that are key to working effectively with these frameworks.&lt;/p>
&lt;h2 id="what-is-the-future-of-vanilla-javascript">What Is the Future of Vanilla JavaScript?
&lt;/h2>&lt;p>With 25 years of existence and a vast community behind it, JavaScript offers a wide range of options and tools for developers of all levels, from beginners to experts. Its flexibility allows it to run both on the client side and the server side, adapting to various project needs.&lt;/p>
&lt;p>Contrary to what some might think, JavaScript remains a solid foundation for anyone who wants to deeply understand how the web works. With advancements in &lt;strong>APIs&lt;/strong> and the introduction of modern features like &lt;strong>ES6+&lt;/strong>, the language has become even more powerful and practical. The community has also contributed significantly, creating an extensive array of plugins, libraries, and frameworks that have cemented JavaScript as an essential language for web development.&lt;/p>
&lt;p>Moreover, trends like &lt;strong>Web Components&lt;/strong> — a native specification for creating reusable components — are encouraging the use of Vanilla JavaScript alongside HTML and CSS. This reaffirms that even in more advanced development scenarios, JavaScript will remain relevant and fundamental.&lt;/p>
&lt;h2 id="frameworks-or-javascript">Frameworks or JavaScript?
&lt;/h2>&lt;p>If you’re starting in web development, it’s natural to ask: &amp;ldquo;Where should I begin?&amp;rdquo; The answer depends on your time and goals.&lt;/p>
&lt;p>If you have time, it’s ideal to start with &lt;strong>JavaScript&lt;/strong>. It is the foundation of everything in web development, and mastering Vanilla JavaScript will make it easier to learn any framework or library in the future.&lt;/p>
&lt;p>However, if time is limited and you need to start with a framework, pick your favorite. But even then, don’t neglect studying JavaScript in parallel. This knowledge will be essential for your growth as a developer, helping you solidify the foundation upon which frameworks are built.&lt;/p></description></item><item><title>Have You Heard of Hoisting?</title><link>https://paulabicca.github.io/en/p/have-you-heard-of-hoisting/</link><pubDate>Thu, 09 Jan 2025 00:00:00 +0000</pubDate><guid>https://paulabicca.github.io/en/p/have-you-heard-of-hoisting/</guid><description>&lt;p>Have you ever come across code where a variable seemed to be used before its declaration and felt confused about what was happening? That’s &lt;strong>hoisting&lt;/strong> in JavaScript!
Let’s explore this basic concept, how scopes matter to it, and its implications.&lt;/p>
&lt;hr>
&lt;h2 id="scope-a-context-for-hoisting">&lt;strong>Scope: A Context for Hoisting&lt;/strong>
&lt;/h2>&lt;p>Before we talk about what &lt;strong>hoisting&lt;/strong> is, we first need to understand a bit more about scopes. In JavaScript, the scope is the context where a variable can be accessed or used.
There are three main types of scope:&lt;/p>
&lt;h2 id="types-of-scope">&lt;strong>Types of Scope&lt;/strong>
&lt;/h2>&lt;h3 id="global-scope">&lt;strong>Global Scope&lt;/strong>
&lt;/h3>&lt;p>Variables declared outside any function or block are in the global scope, accessible from anywhere in the code.&lt;/p>
&lt;p>&lt;strong>Example:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">globalVar&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;I’m in the global scope!&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">showGlobal&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">globalVar&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">showGlobal&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">The output of the above code is: &amp;#34;I’m in the global scope!&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="local-or-function-scope">&lt;strong>Local (or Function) Scope&lt;/strong>
&lt;/h3>&lt;p>Variables declared inside a function can only be accessed within that function.&lt;/p>
&lt;p>&lt;strong>Example:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">myFunction&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">localVar&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;I’m in the local scope!&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">localVar&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// &amp;#34;I’m in the local scope!&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">myFunction&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">localVar&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// ReferenceError: localVar is not defined
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="block-scope">&lt;strong>Block Scope&lt;/strong>
&lt;/h3>&lt;p>Introduced in ES6, variables declared with &lt;code>let&lt;/code> or &lt;code>const&lt;/code> inside a block {} are limited to that block.&lt;/p>
&lt;p>&lt;strong>Example:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">blockVar&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;I’m in the block scope!&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">blockVar&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// &amp;#34;I’m in the block scope!&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">blockVar&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// ReferenceError: blockVar is not defined
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>Now that we understand scope, let’s dive deeper into &lt;strong>Hoisting&lt;/strong>.&lt;/p>
&lt;h2 id="what-is-hoisting">&lt;strong>What is Hoisting?&lt;/strong>
&lt;/h2>&lt;p>&lt;strong>Hoisting&lt;/strong> is a JavaScript behavior that allows you to use a function or variable before it’s declared. This happens because the hoisting mechanism lifts declarations to the top of their scope, making them accessible before they are defined in the code. For a more detailed explanation, you can find one &lt;a class="link" href="https://developer.mozilla.org/pt-BR/docs/Glossary/Hoisting" target="_blank" rel="noopener"
>here&lt;/a>.&lt;/p>
&lt;p>Now that you have an explanation, let’s look at some examples.&lt;/p>
&lt;h3 id="examples-of-hoisting">&lt;strong>Examples of Hoisting&lt;/strong>
&lt;/h3>&lt;h4 id="with-variable">&lt;strong>With Variable&lt;/strong>
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">myVariable&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Initialize myVariable
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;This will be 3:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">myVariable&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// Output is 3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">myVariable&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Declare myVariable for hoisting
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Here, the variable &lt;code>myVariable&lt;/code> was &amp;ldquo;hoisted&amp;rdquo; to the top of the code, which is why the console log output is &lt;code>3&lt;/code>.&lt;/p>
&lt;hr>
&lt;h4 id="with-function">&lt;strong>With Function&lt;/strong>
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">fullName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Jane&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Doe&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">fullName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">lastName&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sb">`My name is &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb"> &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">lastName&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">The output of the above code is: &amp;#34;My name is Jane Doe&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Even if we call the function in our code before the function is written, the code still works.&lt;/p>
&lt;h4 id="with-let-and-const">&lt;strong>With &lt;code>let&lt;/code> and &lt;code>const&lt;/code>&lt;/strong>
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">myVariable&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// ReferenceError: Cannot access &amp;#39;myVariable&amp;#39; before initialization
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">myConstVariable&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// SyntaxError: Missing initializer in const declaration
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">myVariable&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;Hello, World!&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">myConstVariable&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;Hello, World!&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Unlike &lt;code>var&lt;/code>, variables declared with &lt;code>let&lt;/code> or &lt;code>const&lt;/code> are hoisted but remain in a “&lt;strong>Temporal Dead Zone (TDZ)&lt;/strong>” until they are declared.&lt;/p>
&lt;h4 id="what-is-the-temporal-dead-zone">&lt;strong>What is the Temporal Dead Zone?&lt;/strong>
&lt;/h4>&lt;p>The TDZ is the period between a variable’s creation and its declaration in the code. During the TDZ, the variable exists but hasn’t been initialized yet, and accessing it in this interval throws a ReferenceError. The TDZ primarily affects variables declared with &lt;code>let&lt;/code> and &lt;code>const&lt;/code>, as they adhere to their scopes, unlike &lt;code>var&lt;/code>.&lt;/p>
&lt;hr>
&lt;h2 id="possible-use-cases">&lt;strong>Possible Use Cases&lt;/strong>
&lt;/h2>&lt;p>&lt;strong>Hoisting&lt;/strong> itself isn’t a technique or feature you choose to use directly but rather a JavaScript behavior. So, the question isn’t about using &lt;strong>hoisting&lt;/strong> but understanding how it works to avoid pitfalls and leverage specific situations.&lt;/p>
&lt;h3 id="when-it-makes-sense">&lt;strong>When it Makes Sense&lt;/strong>
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>Legacy Scripts with var&lt;/strong>&lt;br>
In older projects that still use &lt;code>var&lt;/code>, hoisting can be useful for understanding how variables are treated. However, it’s not recommended to adopt &lt;code>var&lt;/code> in new projects, as it’s prone to confusion and bugs.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Older Libraries and Frameworks&lt;/strong>&lt;br>
If you work with libraries or frameworks that haven’t adopted modern standards (like ES6), understanding hoisting is crucial for debugging and avoiding errors.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Code Prototypes and Learning&lt;/strong>&lt;br>
When learning JavaScript, hoisting can help you understand how the language handles variables and functions under the hood. However, it’s important to learn best practices early on, like always declaring variables before using them.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="when-it-doesnt-make-sense">&lt;strong>When it Doesn’t Make Sense&lt;/strong>
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>Novos Projetos Modernos&lt;/strong>&lt;br>
With &lt;code>let&lt;/code> and &lt;code>const&lt;/code>, hoisting becomes less relevant because these variables cannot be used before their declaration. This creates a more predictable and less error-prone approach.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Best Practices and Readability&lt;/strong>&lt;br>
Although hoisting allows you to run code before its declaration, it’s not a recommended practice as it can make code confusing for other developers (or even for yourself in the future).&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="is-hoisting-still-relevant-today">&lt;strong>Is Hoisting Still Relevant Today?&lt;/strong>
&lt;/h2>&lt;p>Does hoisting still make sense today? Yes, no, maybe… hahaha!
All jokes aside, hoisting is still useful in specific situations, such as using function declarations and maintaining legacy projects. However, in modern projects, the scenario is different.
Here are some tips to handle variables and avoid issues:&lt;/p>
&lt;ul>
&lt;li>Prefer &lt;code>let&lt;/code> and &lt;code>const&lt;/code>.&lt;/li>
&lt;li>Declare variables at the beginning of the scope where they will be used.&lt;/li>
&lt;li>Avoid relying on the implicit behavior of hoisting to ensure more readable and predictable code.&lt;/li>
&lt;/ul>
&lt;p>While the direct use of the hoisting concept is becoming less common, understanding how it works remains an essential skill for every JavaScript developer.&lt;br>
After all, knowledge is never too much, right? :)&lt;/p></description></item></channel></rss>